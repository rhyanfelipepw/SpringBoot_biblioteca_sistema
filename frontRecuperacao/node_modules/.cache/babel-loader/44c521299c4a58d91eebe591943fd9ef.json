{"ast":null,"code":"import { LABEL_PADDING_HORIZONTAL, ADORNMENT_OFFSET, ADORNMENT_SIZE, FLAT_INPUT_OFFSET } from './constants';\nimport { AdornmentType, AdornmentSide } from './Adornment/enums';\nexport const calculateLabelTopPosition = function (labelHeight) {\n  let height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let optionalPadding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  const customHeight = height > 0 ? height : 0;\n  return Math.floor((customHeight - labelHeight) / 2 + optionalPadding);\n};\nexport const calculateInputHeight = function (labelHeight) {\n  let height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let minHeight = arguments.length > 2 ? arguments[2] : undefined;\n  const finalHeight = height > 0 ? height : labelHeight;\n  if (height > 0) return height;\n  return finalHeight < minHeight ? minHeight : finalHeight;\n};\nexport const calculatePadding = props => {\n  const {\n    height,\n    multiline = false\n  } = props;\n  let result = 0;\n\n  if (multiline) {\n    if (height && multiline) {\n      result = calculateTextAreaPadding(props);\n    } else {\n      result = calculateInputPadding(props);\n    }\n  }\n\n  return Math.max(0, result);\n};\n\nconst calculateTextAreaPadding = props => {\n  const {\n    dense\n  } = props;\n  return dense ? 10 : 20;\n};\n\nconst calculateInputPadding = _ref => {\n  let {\n    topPosition,\n    fontSize,\n    multiline,\n    scale,\n    dense,\n    offset,\n    isAndroid\n  } = _ref;\n  const refFontSize = scale * fontSize;\n  let result = Math.floor(topPosition / 2);\n  result = result + Math.floor((refFontSize - fontSize) / 2) - (scale < 1 ? offset / 2 : 0);\n  if (multiline && isAndroid) result = Math.min(dense ? offset / 2 : offset, result);\n  return result;\n};\n\nexport const adjustPaddingOut = _ref2 => {\n  let {\n    pad,\n    multiline,\n    label,\n    scale,\n    height,\n    fontSize,\n    lineHeight,\n    dense,\n    offset,\n    isAndroid\n  } = _ref2;\n  const fontHeight = lineHeight !== null && lineHeight !== void 0 ? lineHeight : fontSize;\n  const refFontHeight = scale * fontSize;\n  let result = pad;\n\n  if (height && !multiline) {\n    return {\n      paddingTop: Math.max(0, (height - fontHeight) / 2),\n      paddingBottom: Math.max(0, (height - fontHeight) / 2)\n    };\n  }\n\n  if (!isAndroid && multiline) {\n    if (dense) {\n      if (label) {\n        result += scale < 1 ? Math.min(offset, refFontHeight / 2 * scale) : 0;\n      } else {\n        result += 0;\n      }\n    }\n\n    if (!dense) {\n      if (label) {\n        result += scale < 1 ? Math.min(offset, refFontHeight * scale) : Math.min(offset / 2, refFontHeight * scale);\n      } else {\n        result += scale < 1 ? Math.min(offset / 2, refFontHeight * scale) : 0;\n      }\n    }\n\n    result = Math.floor(result);\n  }\n\n  return {\n    paddingTop: result,\n    paddingBottom: result\n  };\n};\nexport const adjustPaddingFlat = _ref3 => {\n  let {\n    pad,\n    scale,\n    multiline,\n    label,\n    height,\n    offset,\n    dense,\n    fontSize,\n    isAndroid,\n    styles\n  } = _ref3;\n  let result = pad;\n  let topResult = result;\n  let bottomResult = result;\n  const {\n    paddingTop,\n    paddingBottom\n  } = styles;\n  const refFontSize = scale * fontSize;\n\n  if (!multiline) {\n    // do not modify padding if input is not multiline\n    if (label) {\n      // return const style for flat input with label\n      return {\n        paddingTop,\n        paddingBottom\n      };\n    } // return pad for flat input without label\n\n\n    return {\n      paddingTop: result,\n      paddingBottom: result\n    };\n  }\n\n  if (label) {\n    // add paddings passed from styles\n    topResult = paddingTop;\n    bottomResult = paddingBottom; // adjust top padding for iOS\n\n    if (!isAndroid) {\n      if (dense) {\n        topResult += scale < 1 ? Math.min(result, refFontSize * scale) - result / 2 : Math.min(result, refFontSize * scale) - result / 2;\n      }\n\n      if (!dense) {\n        topResult += scale < 1 ? Math.min(offset / 2, refFontSize * scale) : Math.min(result, refFontSize * scale) - offset / 2;\n      }\n    }\n\n    topResult = Math.floor(topResult);\n  } else {\n    if (height) {\n      // center text when height is passed\n      return {\n        paddingTop: Math.max(0, (height - fontSize) / 2),\n        paddingBottom: Math.max(0, (height - fontSize) / 2)\n      };\n    } // adjust paddings for iOS if no label\n\n\n    if (!isAndroid) {\n      if (dense) {\n        result += scale < 1 ? Math.min(offset / 2, fontSize / 2 * scale) : Math.min(offset / 2, scale);\n      }\n\n      if (!dense) {\n        result += scale < 1 ? Math.min(offset, fontSize * scale) : Math.min(fontSize, offset / 2 * scale);\n      }\n\n      result = Math.floor(result);\n      topResult = result;\n      bottomResult = result;\n    }\n  }\n\n  return {\n    paddingTop: Math.max(0, topResult),\n    paddingBottom: Math.max(0, bottomResult)\n  };\n};\nexport const interpolatePlaceholder = (labeled, hasActiveOutline) => labeled.interpolate({\n  inputRange: [0, 1],\n  outputRange: [hasActiveOutline ? 0 : 1, 1]\n});\nexport function calculateFlatAffixTopPosition(_ref4) {\n  let {\n    height,\n    paddingTop,\n    paddingBottom,\n    affixHeight\n  } = _ref4;\n  const inputHeightWithoutPadding = height - paddingTop - paddingBottom;\n  const halfOfTheInputHeightDecreasedByAffixHeight = (inputHeightWithoutPadding - affixHeight) / 2;\n  return paddingTop + halfOfTheInputHeightDecreasedByAffixHeight;\n}\nexport function calculateOutlinedIconAndAffixTopPosition(_ref5) {\n  let {\n    height,\n    affixHeight,\n    labelYOffset\n  } = _ref5;\n  return (height - affixHeight + labelYOffset) / 2;\n}\nexport const calculateFlatInputHorizontalPadding = _ref6 => {\n  let {\n    adornmentConfig\n  } = _ref6;\n  let paddingLeft = LABEL_PADDING_HORIZONTAL;\n  let paddingRight = LABEL_PADDING_HORIZONTAL;\n  adornmentConfig.forEach(_ref7 => {\n    let {\n      type,\n      side\n    } = _ref7;\n\n    if (type === AdornmentType.Icon && side === AdornmentSide.Left) {\n      paddingLeft = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n    } else if (side === AdornmentSide.Right) {\n      if (type === AdornmentType.Affix) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      } else if (type === AdornmentType.Icon) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      }\n    }\n  });\n  return {\n    paddingLeft,\n    paddingRight\n  };\n};\nexport function areLabelsEqual(label1, label2) {\n  if (label1 === label2) {\n    // will also take care of equality for `string` type, or if both are undefined.\n    return true;\n  } // Return true if both of them are falsy.\n\n\n  if (!(label1 || label2)) {\n    return true;\n  } // At this point, both of them cannot be false.\n  // So, return false if any of them is falsy.\n\n\n  if (!(label1 && label2)) {\n    return false;\n  } // At this point, both of them has to be truthy.\n  // So, return false if they are not of the same type.\n\n\n  if (typeof label1 !== typeof label2) {\n    return false;\n  } // At this point, both of them has to be of the same datatype.\n\n\n  if (typeof label1 === 'string' || label1 instanceof String || // These last two OR checks are only here for Typescript's sake.\n  typeof label2 === 'string' || label2 instanceof String) {\n    // They're strings, so they won't be equal; otherwise\n    //  we would have returned 'true' earlier.\n    return false;\n  } // At this point, both of them has to be of the datatype: `React.ReactElement`.\n\n\n  if (label1.type !== label2.type) {\n    return false;\n  } // Preliminary equality check: do they stringify to the same string?\n\n\n  const label1Props = label1.props || {};\n  const label2Props = label2.props || {};\n\n  if (JSON.stringify(label1Props) !== JSON.stringify(label2Props)) {\n    return false;\n  } // We now know they stringify to the same string.\n  // Return true if both of them DO NOT have children\n\n\n  if (!(label1Props.children || label2Props.children)) {\n    return true; // since there's nothing else to check\n  } // Return false if only one of them has children\n\n\n  if (!(label1Props.children && label2Props.children)) {\n    return false;\n  } // Both have children...\n  // Handle for when both the children are arrays\n\n\n  const label1IsArray = Array.isArray(label1Props.children);\n  const label2IsArray = Array.isArray(label2Props.children);\n\n  if (label1IsArray && label2IsArray) {\n    const children1 = label1Props.children;\n    const children2 = label2Props.children;\n\n    if (children1.length !== children2.length) {\n      return false; // no point proceeding\n    } // all the children must also be equal\n\n\n    for (let i = 0; i < children1.length; i++) {\n      if (!areLabelsEqual(children1[i], children2[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  } // Only one of them can be an array at this point. If any is array, return false\n\n\n  if (label1IsArray || label2IsArray) {\n    return false;\n  } // both children are not arrays, so recur.\n\n\n  return areLabelsEqual(label1Props.children, label2Props.children);\n}","map":{"version":3,"sources":["helpers.tsx"],"names":["calculateLabelTopPosition","height","optionalPadding","customHeight","Math","calculateInputHeight","finalHeight","calculatePadding","props","multiline","result","calculateTextAreaPadding","calculateInputPadding","dense","isAndroid","refFontSize","scale","topPosition","offset","adjustPaddingOut","fontHeight","lineHeight","refFontHeight","paddingTop","paddingBottom","adjustPaddingFlat","styles","topResult","bottomResult","fontSize","interpolatePlaceholder","inputRange","outputRange","hasActiveOutline","affixHeight","inputHeightWithoutPadding","halfOfTheInputHeightDecreasedByAffixHeight","labelYOffset","calculateFlatInputHorizontalPadding","adornmentConfig","paddingLeft","paddingRight","side","type","AdornmentType","AdornmentSide","ADORNMENT_SIZE","label1","label2","label1Props","label2Props","JSON","label1IsArray","Array","label2IsArray","children1","children2","i","areLabelsEqual"],"mappings":"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","sourcesContent":["import type { Animated } from 'react-native';\nimport type { AdornmentConfig } from './Adornment/types';\nimport {\n  LABEL_PADDING_HORIZONTAL,\n  ADORNMENT_OFFSET,\n  ADORNMENT_SIZE,\n  FLAT_INPUT_OFFSET,\n} from './constants';\nimport { AdornmentType, AdornmentSide } from './Adornment/enums';\nimport type { TextInputLabelProp } from './types';\n\ntype PaddingProps = {\n  height: number | null;\n  labelHalfHeight: number;\n  multiline: boolean | null;\n  dense: boolean | null;\n  topPosition: number;\n  fontSize: number;\n  lineHeight?: number;\n  label?: TextInputLabelProp | null;\n  scale: number;\n  offset: number;\n  isAndroid: boolean;\n  styles: { paddingTop: number; paddingBottom: number };\n};\n\ntype AdjProps = PaddingProps & {\n  pad: number;\n};\n\nexport type Padding = { paddingTop: number; paddingBottom: number };\n\nexport const calculateLabelTopPosition = (\n  labelHeight: number,\n  height: number = 0,\n  optionalPadding: number = 0\n): number => {\n  const customHeight = height > 0 ? height : 0;\n\n  return Math.floor((customHeight - labelHeight) / 2 + optionalPadding);\n};\n\nexport const calculateInputHeight = (\n  labelHeight: number,\n  height: any = 0,\n  minHeight: number\n): number => {\n  const finalHeight = height > 0 ? height : labelHeight;\n\n  if (height > 0) return height;\n  return finalHeight < minHeight ? minHeight : finalHeight;\n};\n\nexport const calculatePadding = (props: PaddingProps): number => {\n  const { height, multiline = false } = props;\n\n  let result = 0;\n\n  if (multiline) {\n    if (height && multiline) {\n      result = calculateTextAreaPadding(props);\n    } else {\n      result = calculateInputPadding(props);\n    }\n  }\n\n  return Math.max(0, result);\n};\n\nconst calculateTextAreaPadding = (props: PaddingProps) => {\n  const { dense } = props;\n\n  return dense ? 10 : 20;\n};\n\nconst calculateInputPadding = ({\n  topPosition,\n  fontSize,\n  multiline,\n  scale,\n  dense,\n  offset,\n  isAndroid,\n}: PaddingProps): number => {\n  const refFontSize = scale * fontSize;\n  let result = Math.floor(topPosition / 2);\n\n  result =\n    result +\n    Math.floor((refFontSize - fontSize) / 2) -\n    (scale < 1 ? offset / 2 : 0);\n\n  if (multiline && isAndroid)\n    result = Math.min(dense ? offset / 2 : offset, result);\n\n  return result;\n};\n\nexport const adjustPaddingOut = ({\n  pad,\n  multiline,\n  label,\n  scale,\n  height,\n  fontSize,\n  lineHeight,\n  dense,\n  offset,\n  isAndroid,\n}: AdjProps): Padding => {\n  const fontHeight = lineHeight ?? fontSize;\n  const refFontHeight = scale * fontSize;\n  let result = pad;\n\n  if (height && !multiline) {\n    return {\n      paddingTop: Math.max(0, (height - fontHeight) / 2),\n      paddingBottom: Math.max(0, (height - fontHeight) / 2),\n    };\n  }\n  if (!isAndroid && multiline) {\n    if (dense) {\n      if (label) {\n        result += scale < 1 ? Math.min(offset, (refFontHeight / 2) * scale) : 0;\n      } else {\n        result += 0;\n      }\n    }\n    if (!dense) {\n      if (label) {\n        result +=\n          scale < 1\n            ? Math.min(offset, refFontHeight * scale)\n            : Math.min(offset / 2, refFontHeight * scale);\n      } else {\n        result += scale < 1 ? Math.min(offset / 2, refFontHeight * scale) : 0;\n      }\n    }\n    result = Math.floor(result);\n  }\n  return { paddingTop: result, paddingBottom: result };\n};\n\nexport const adjustPaddingFlat = ({\n  pad,\n  scale,\n  multiline,\n  label,\n  height,\n  offset,\n  dense,\n  fontSize,\n  isAndroid,\n  styles,\n}: AdjProps): Padding => {\n  let result = pad;\n  let topResult = result;\n  let bottomResult = result;\n  const { paddingTop, paddingBottom } = styles;\n  const refFontSize = scale * fontSize;\n\n  if (!multiline) {\n    // do not modify padding if input is not multiline\n    if (label) {\n      // return const style for flat input with label\n      return { paddingTop, paddingBottom };\n    }\n    // return pad for flat input without label\n    return { paddingTop: result, paddingBottom: result };\n  }\n\n  if (label) {\n    // add paddings passed from styles\n    topResult = paddingTop;\n    bottomResult = paddingBottom;\n\n    // adjust top padding for iOS\n    if (!isAndroid) {\n      if (dense) {\n        topResult +=\n          scale < 1\n            ? Math.min(result, refFontSize * scale) - result / 2\n            : Math.min(result, refFontSize * scale) - result / 2;\n      }\n      if (!dense) {\n        topResult +=\n          scale < 1\n            ? Math.min(offset / 2, refFontSize * scale)\n            : Math.min(result, refFontSize * scale) - offset / 2;\n      }\n    }\n    topResult = Math.floor(topResult);\n  } else {\n    if (height) {\n      // center text when height is passed\n      return {\n        paddingTop: Math.max(0, (height - fontSize) / 2),\n        paddingBottom: Math.max(0, (height - fontSize) / 2),\n      };\n    }\n    // adjust paddings for iOS if no label\n    if (!isAndroid) {\n      if (dense) {\n        result +=\n          scale < 1\n            ? Math.min(offset / 2, (fontSize / 2) * scale)\n            : Math.min(offset / 2, scale);\n      }\n      if (!dense) {\n        result +=\n          scale < 1\n            ? Math.min(offset, fontSize * scale)\n            : Math.min(fontSize, (offset / 2) * scale);\n      }\n\n      result = Math.floor(result);\n      topResult = result;\n      bottomResult = result;\n    }\n  }\n\n  return {\n    paddingTop: Math.max(0, topResult),\n    paddingBottom: Math.max(0, bottomResult),\n  };\n};\n\nexport const interpolatePlaceholder = (\n  labeled: Animated.Value,\n  hasActiveOutline: boolean | undefined\n) =>\n  labeled.interpolate({\n    inputRange: [0, 1],\n    outputRange: [hasActiveOutline ? 0 : 1, 1],\n  });\n\nexport function calculateFlatAffixTopPosition({\n  height,\n  paddingTop,\n  paddingBottom,\n  affixHeight,\n}: {\n  height: number;\n  paddingTop: number;\n  paddingBottom: number;\n  affixHeight: number;\n}): number {\n  const inputHeightWithoutPadding = height - paddingTop - paddingBottom;\n\n  const halfOfTheInputHeightDecreasedByAffixHeight =\n    (inputHeightWithoutPadding - affixHeight) / 2;\n\n  return paddingTop + halfOfTheInputHeightDecreasedByAffixHeight;\n}\n\nexport function calculateOutlinedIconAndAffixTopPosition({\n  height,\n  affixHeight,\n  labelYOffset,\n}: {\n  height: number;\n  affixHeight: number;\n  labelYOffset: number;\n}): number {\n  return (height - affixHeight + labelYOffset) / 2;\n}\n\nexport const calculateFlatInputHorizontalPadding = ({\n  adornmentConfig,\n}: {\n  adornmentConfig: AdornmentConfig[];\n}) => {\n  let paddingLeft = LABEL_PADDING_HORIZONTAL;\n  let paddingRight = LABEL_PADDING_HORIZONTAL;\n\n  adornmentConfig.forEach(({ type, side }) => {\n    if (type === AdornmentType.Icon && side === AdornmentSide.Left) {\n      paddingLeft = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n    } else if (side === AdornmentSide.Right) {\n      if (type === AdornmentType.Affix) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      } else if (type === AdornmentType.Icon) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      }\n    }\n  });\n\n  return { paddingLeft, paddingRight };\n};\n\nexport function areLabelsEqual(\n  label1?: TextInputLabelProp,\n  label2?: TextInputLabelProp\n): boolean {\n  if (label1 === label2) {\n    // will also take care of equality for `string` type, or if both are undefined.\n    return true;\n  }\n\n  // Return true if both of them are falsy.\n  if (!(label1 || label2)) {\n    return true;\n  }\n\n  // At this point, both of them cannot be false.\n  // So, return false if any of them is falsy.\n  if (!(label1 && label2)) {\n    return false;\n  }\n\n  // At this point, both of them has to be truthy.\n  // So, return false if they are not of the same type.\n  if (typeof label1 !== typeof label2) {\n    return false;\n  }\n\n  // At this point, both of them has to be of the same datatype.\n  if (\n    typeof label1 === 'string' ||\n    label1 instanceof String ||\n    // These last two OR checks are only here for Typescript's sake.\n    typeof label2 === 'string' ||\n    label2 instanceof String\n  ) {\n    // They're strings, so they won't be equal; otherwise\n    //  we would have returned 'true' earlier.\n    return false;\n  }\n\n  // At this point, both of them has to be of the datatype: `React.ReactElement`.\n  if (label1.type !== label2.type) {\n    return false;\n  }\n\n  // Preliminary equality check: do they stringify to the same string?\n  const label1Props = label1.props || {};\n  const label2Props = label2.props || {};\n  if (JSON.stringify(label1Props) !== JSON.stringify(label2Props)) {\n    return false;\n  }\n\n  // We now know they stringify to the same string.\n  // Return true if both of them DO NOT have children\n  if (!(label1Props.children || label2Props.children)) {\n    return true; // since there's nothing else to check\n  }\n\n  // Return false if only one of them has children\n  if (!(label1Props.children && label2Props.children)) {\n    return false;\n  }\n\n  // Both have children...\n  // Handle for when both the children are arrays\n  const label1IsArray = Array.isArray(label1Props.children);\n  const label2IsArray = Array.isArray(label2Props.children);\n  if (label1IsArray && label2IsArray) {\n    const children1 = label1Props.children as any[];\n    const children2 = label2Props.children as any[];\n    if (children1.length !== children2.length) {\n      return false; // no point proceeding\n    }\n\n    // all the children must also be equal\n    for (let i = 0; i < children1.length; i++) {\n      if (!areLabelsEqual(children1[i], children2[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // Only one of them can be an array at this point. If any is array, return false\n  if (label1IsArray || label2IsArray) {\n    return false;\n  }\n\n  // both children are not arrays, so recur.\n  return areLabelsEqual(label1Props.children, label2Props.children);\n}\n"]},"metadata":{},"sourceType":"module"}